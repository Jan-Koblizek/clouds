/*
Copyright (c) 2020 Jan Koblížek

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

Shader "Skybox/Skybox-Image" {
	Properties{
		//Unity procedural shader variables
		[HideInInspector]_SunTint("Sun Tint", Color) = (1, 1, 1, 1)
		[HideInInspector]_SunStrength("Sun Strength", Float) = 1.0
		[HideInInspector]_Color("Atmosphere Tint", Color) = (.8, .8, .8, 1)
		[HideInInspector]_GroundColor("Ground", Color) = (.369, .349, .341, 1)
		[HideInInspector]_HdrExposure("HDR Exposure", Float) = 1.3
		//Cloud texture generated in Clouds_Texture.shader
		[HideInInspector]_Texture("Texture", 2D) = "white"
	}

		SubShader{
			Tags { "Queue" = "Background" "RenderType" = "Background" "PreviewType" = "Skybox" }
			Cull Off ZWrite Off

			Pass {
				CGPROGRAM
				#pragma vertex vert
				#pragma fragment frag

				#include "UnityCG.cginc"
				#include "Lighting.cginc"

				//Variables and constants of the Unity procedural shader
				uniform half _HdrExposure;		// HDR exposure
				uniform half3 _GroundColor;

				half3 _Color;
				half3 _SunTint;
				half _SunStrength;

				// RGB wavelengths
				#define GAMMA .454545
				static const float MN = 2;
				static const float MX = .7;
				#define WR (0.65*lerp(MN, MX, pow(_Color.r,GAMMA)))
				#define WG (0.57*lerp(MN, MX, pow(_Color.g,GAMMA)))
				#define WB (0.475*lerp(MN, MX, pow(_Color.b,GAMMA)))
				//#define WR pow(0.65,GAMMA)
				//#define WG pow(0.57,GAMMA)
				//#define WB pow(0.475,GAMMA)
				static const float3 kInvWavelength = float3(1.0 / (WR*WR*WR*WR), 1.0 / (WG*WG*WG*WG), 1.0 / (WB*WB*WB*WB));
				#define OUTER_RADIUS 1.025
				static const float kOuterRadius = OUTER_RADIUS;
				static const float kOuterRadius2 = OUTER_RADIUS * OUTER_RADIUS;
				static const float kInnerRadius = 1.0;
				static const float kInnerRadius2 = 1.0;

				static const float kCameraHeight = 0.0001;

				#define kRAYLEIGH 0.0025		// Rayleigh constant
				#define kMIE 0.0010      		// Mie constant
				#define kSUN_BRIGHTNESS 20.0 	// Sun brightness

				static const float kKrESun = kRAYLEIGH * kSUN_BRIGHTNESS;
				static const float kKmESun = kMIE * kSUN_BRIGHTNESS;
				static const float kKr4PI = kRAYLEIGH * 4.0 * 3.14159265;
				static const float kKm4PI = kMIE * 4.0 * 3.14159265;
				static const float kScale = 1.0 / (OUTER_RADIUS - 1.0);
				static const float kScaleDepth = 0.25;
				static const float kScaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;
				static const float kSamples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH

				#define MIE_G (-0.990)
				#define MIE_G2 0.9801

				//Cloud texture generated by Clouds_Texture.shader
				sampler2D _Texture;


				struct appdata_t {
					float4 vertex : POSITION;
				};

				struct v2f {
						float4 pos : SV_POSITION;
						float3 rayDir : TEXCOORD0;	// Vector for incoming ray, normalized ( == -eyeRay )
						half3 cIn : TEXCOORD1; 		// In-scatter coefficient
						half3 cOut : TEXCOORD2;		// Out-scatter coefficient
				};

				//generates pseudorandom float from 3D coordinates
				float random(in float3 st) {
					st = frac(st * 0.1031);
					st += dot(st, st.yzx + 19.19);
					return frac((st.x + st.y) * st.z);
				}

				//3D perlin noise - not layered
				float noise(float3 st, int mult) {
					float3 i = floor(st);
					float3 fr = frac(st);

					// 8 corners in 3D of a cube
					float a = random(i);
					float b = random((i + float3(1.0, 0.0, 0.0)) % mult);
					float c = random((i + float3(0.0, 1.0, 0.0)) % mult);
					float d = random((i + float3(1.0, 1.0, 0.0)) % mult);

					float e = random((i + float3(0.0, 0.0, 1.0)) % mult);
					float f = random((i + float3(1.0, 0.0, 1.0)) % mult);
					float g = random((i + float3(0.0, 1.0, 1.0)) % mult);
					float h = random((i + float3(1.0, 1.0, 1.0)) % mult);

					float3 u = fr * fr * (3.0 - 2.0 * fr);

					return lerp(lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y), lerp(lerp(e, f, u.x), lerp(g, h, u.x), u.y), u.z);
				}

				/*
				Generates 3D layered perlin noise to add detail to low detail cloud texture (8 octaves)
				*/
				#define OCTAVES 8
				float fbm(float3 st, int mult) {

					float value = 0.0;
					float amplitude = .5;
					float frequency = 0.;

					for (int i = 0; i < OCTAVES; i++) {
						value += amplitude * noise(st, mult);
						st *= 2.;
						mult *= 2.;
						amplitude *= .5;
					}
					return value;
				}

				/*
				Gets distance to the cloud plane
				*/
				float intersectClouds(float3 rd, float r) {
					return r / (rd.y + 0.01);
				}

				//Unity procedural skybox shader code
				float scale(float inCos)
				{
					float x = 1.0 - inCos;
					return 0.25 * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
				}

				//Unity procedural skybox vertex shader
				v2f vert(appdata_t v)
				{
					v2f OUT;
					OUT.pos = UnityObjectToClipPos(v.vertex);

					float3 cameraPos = float3(0,kInnerRadius + kCameraHeight,0); 	// The camera's current position

					// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
					float3 eyeRay = normalize(mul((float3x3)unity_ObjectToWorld, v.vertex.xyz));

					OUT.rayDir = -eyeRay;

					float far = 0.0;
					if (eyeRay.y >= 0.0)
					{
						// Sky
						// Calculate the length of the "atmosphere"
						far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;

						float3 pos = cameraPos + far * eyeRay;

						// Calculate the ray's starting position, then calculate its scattering offset
						float height = kInnerRadius + kCameraHeight;
						float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));
						float startAngle = dot(eyeRay, cameraPos) / height;
						float startOffset = depth * scale(startAngle);


						// Initialize the scattering loop variables
						float sampleLength = far / kSamples;
						float scaledLength = sampleLength * kScale;
						float3 sampleRay = eyeRay * sampleLength;
						float3 samplePoint = cameraPos + sampleRay * 0.5;

						// Now loop through the sample rays
						float3 frontColor = float3(0.0, 0.0, 0.0);
						// WTF BBQ: WP8 and desktop FL_9_1 do not like the for loop here
						// (but an almost identical loop is perfectly fine in the ground calculations below)
						// Just unrolling this manually seems to make everything fine again.
		//				for(int i=0; i<int(kSamples); i++)
						{
							float height = length(samplePoint);
							float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
							float lightAngle = dot(_WorldSpaceLightPos0.xyz, samplePoint) / height;
							float cameraAngle = dot(eyeRay, samplePoint) / height;
							float scatter = (startOffset + depth * (scale(lightAngle) - scale(cameraAngle)));
							float3 attenuate = exp(-scatter * (kInvWavelength * kKr4PI + kKm4PI));

							frontColor += attenuate * (depth * scaledLength);
							samplePoint += sampleRay;
						}
						{
							float height = length(samplePoint);
							float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
							float lightAngle = dot(_WorldSpaceLightPos0.xyz, samplePoint) / height;
							float cameraAngle = dot(eyeRay, samplePoint) / height;
							float scatter = (startOffset + depth * (scale(lightAngle) - scale(cameraAngle)));
							float3 attenuate = exp(-scatter * (kInvWavelength * kKr4PI + kKm4PI));

							frontColor += attenuate * (depth * scaledLength);
							samplePoint += sampleRay;
						}



						// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader
						OUT.cIn.xyz = frontColor * (kInvWavelength * kKrESun);
						OUT.cOut = frontColor * kKmESun;
					}
					else
					{
						// Ground
						far = (-kCameraHeight) / (min(-0.00001, eyeRay.y));

						float3 pos = cameraPos + far * eyeRay;

						// Calculate the ray's starting position, then calculate its scattering offset
						float depth = exp((-kCameraHeight) * (1.0 / kScaleDepth));
						float cameraAngle = dot(-eyeRay, pos);
						float lightAngle = dot(_WorldSpaceLightPos0.xyz, pos);
						float cameraScale = scale(cameraAngle);
						float lightScale = scale(lightAngle);
						float cameraOffset = depth * cameraScale;
						float temp = (lightScale + cameraScale);

						// Initialize the scattering loop variables
						float sampleLength = far / kSamples;
						float scaledLength = sampleLength * kScale;
						float3 sampleRay = eyeRay * sampleLength;
						float3 samplePoint = cameraPos + sampleRay * 0.5;

						// Now loop through the sample rays
						float3 frontColor = float3(0.0, 0.0, 0.0);
						float3 attenuate;
						for (int i = 0; i<int(kSamples); i++)
						{
							float height = length(samplePoint);
							float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
							float scatter = depth * temp - cameraOffset;
							attenuate = exp(-scatter * (kInvWavelength * kKr4PI + kKm4PI));
							frontColor += attenuate * (depth * scaledLength);
							samplePoint += sampleRay;
						}

						OUT.cIn.xyz = frontColor * (kInvWavelength * kKrESun + kKmESun);
						OUT.cOut.xyz = clamp(attenuate, 0.0, 1.0);
					}


					return OUT;

				}


				//Unity procedural skybox - calculates the Mie phase function
				half getMiePhase(half eyeCos, half eyeCos2)
				{
					half temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;
					// A somewhat rough approx for :
					// temp = pow(temp, 1.5);
					temp = smoothstep(0.0, 0.01, temp) * temp;
					temp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision
					return 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;
				}

				//Unity procedural skybox - calculates the Rayleigh phase function
				half getRayleighPhase(half eyeCos2)
				{
					return 0.75 + 0.75*eyeCos2;
				}

				half4 frag(v2f IN) : SV_Target
				{
					half3 col;
					if (IN.rayDir.y < 0.0)
					{
						half eyeCos = dot(_WorldSpaceLightPos0.xyz, normalize(IN.rayDir.xyz));
						half eyeCos2 = eyeCos * eyeCos;
						//Get separately the color of the sky with and without sun 
						half3 colWithoutSun = getRayleighPhase(eyeCos2) * IN.cIn.xyz;
						col = colWithoutSun + getMiePhase(eyeCos, eyeCos2) * IN.cOut * _LightColor0.xyz * _SunTint * _SunStrength;
						float3 rayDir = normalize(-IN.rayDir);

						/*
						Gets x and y coordinates to read from the cloud texture
						We get x and y from the rayDir
						*/
						float y;
						float distSide = sqrt(rayDir.x * rayDir.x + rayDir.z * rayDir.z);
						if (rayDir.y < 0.9)
						{
							y = asin(rayDir.y) / 1.57;
						}
						else {
							y = acos(distSide) / 1.57;
						}
						float x = ((atan2(rayDir.x, rayDir.z) + 3.14) / (2 * 3.14));

						//Read from the cloud texture
						float4 col2 = tex2D(_Texture, float2(x, y) % 1);	
						//Perlin noise is used to add detail to low detail clouds
						//col2.a = pow(col2.a, pow(2, 1 - 2 * pow(fbm((float3(rayDir.x, rayDir.y, rayDir.z) % 1) * 32, 32), 2)));

						
						//Adds atmosphere color/fog to make clouds blend with the atmosphere - greater the distance means more fog
						float dist;
						dist = intersectClouds(rayDir, 550.);
						half3 colFog = colWithoutSun;
						float4 fog = float4(colFog, clamp(pow(dist / 500, 0.33) / 3., 0., 1.));
						col.rgb = lerp(col.rgb, col2.rgb, 1 - col2.a);
						col.rgb = lerp(col.rgb, fog.rgb, fog.a);
					}
					else
					{
						col = IN.cIn.xyz + _GroundColor * IN.cOut;
					}
					//Adjust color from HDR
					col *= _HdrExposure;

					return half4(col.rgb ,1.0);

				}
				ENDCG
			}
	}


		Fallback Off

}
